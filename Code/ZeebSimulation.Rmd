---
title: "Zeeb Simulation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width = 9,  collapse = TRUE, prompt = TRUE, warning = FALSE, message = FALSE)
source("ZeebSimulationFunctions.R")
library(tidyverse)
library(ggplot2)
library(FSA)
library(unmarked)
library(mrds)
```

## 1. one run

### 1.1 get population
Idea with `zeebPop` is to generate mussels individually or within clusters. For most cases, Poisson counts are used to generate population sizes:
$$
N_C \sim Pois(\lambda_1) \\
N_c \sim Pois(\lambda_2) + 1 \ \ c = 1, \dotsc, C \\
N = \sum_{c=1}^C N_c = \ \textrm{population size}
$$
The `nbp` type uses a negative binomial distribution to generate cluster sizes with mean $\lambda_2 + 1$ and dispersion parameter `disp` 

For each option, the expected number of mussels is $\lambda_1(\lambda_2+1)$. Options:

- `none`: The $N$ mussels are uniformly distributed across the region with transect length `len` and width `wid`. 
- `pp`: The $N_C$ cluster "centers" are uniformly distributed across the region. The $N_c$ clusters within cluster $c$ are distributed in a circlar pattern around the cluster center. The radius of each individual is generated by an exponential distribution with mean distance `r.pois` and its angle is generated by a uniform distribution. 
- `matern`: Similar to the `pp` cluster generation but mussels within a cluster are distributed uniformly in a circular pattern with radius `r.fixed` around the cluster center.

```{r}
# lake florida density ~ 0.05  use lam2 = 0, lam1 = 4000
# lake burgan density ~ .5  use lam2 = .4, lam1 = 4000*6
# little birch density ~ 25 use lam2 = 5, lam1 = 4000*80
len <- 20   # transect length
wid <- 4000  # width of lake (circumference)
lam1 <- 4000*3  # mean number of clusters
lam2 <- 30     # mean cluster size = lam2 + 1
lam1*(lam2+1)  # expected number of mussels
lam1*(lam2+1)/(len*wid)  # expected density
r <- .02*1  # Poisson process radius: larger r means less clustering and more randomness (mean dist)
r.fixed <- 2*r # fixed max distance for Matern process
```

```{r}
  # type = "none", "pp" (poisson cluster process), "nbp" (poisson cluster process with negbinom size distribution), "matern" circular matern process
set.seed(83)
zpop <- zeebPop(len, wid, lam1, lam2, disp = NULL, r.pois = r, type = "pp")
(density.zpop <- nrow(zpop)/(len*wid))
```


### 1.2 Sample transects

Suppose we sample $n$ transects of length `len`. Here we pick a random starting point, then systematically add the remaining transects at fixed width apart. 


```{r}
n <- n.tran <- 20   # number of transects
set.seed(43634)
x.samp1 <- runif(1,0,wid/n)  #systematic
x.samp <- c(x.samp1, x.samp1 + (1:(n-1))*wid/n)
#g + geom_vline(xintercept = x.samp)
```

### 1.3 Sample mussels

For each of the `n` transects sampled, collect mussel data based on a distance sample, double transect sample or quadrat sample. 

#### 1.3.1 Double Removal Distance

A sample of mussels is simulated by selecting an individual mussel or a cluster of mussels. The transect half width is set at $w=1$. 

- `cluster = FALSE`: Individual mussel detection probabilities are given by a half-normal function. If mussel $i$ is perpendicular distance (m) $d_i$ from the transect, then $p_i$ is the detection probability: 
$$
p_i = e^{-d_i^2/(2\sigma^2)}
$$
- `cluster = TRUE`: If the "center" of cluster $c$ is perpendicular distance (m) $d_c$ from the transect, then $p_c$ is the cluster detection probability: 
$$
p_c = e^{-d_c^2/(2\sigma^2)}
$$

For each individual (or cluster), let $Y_{i,t}$ be an indicator that mussel $i$ was detected by sampling period $t = 1,2,3$. Note that $Y_{i,3} = 1$ indicates that the mussel was not detected by the two observers. A detection (or not) history is then generated as
$$
(Y_{i,1}, Y_{i,2}, Y_{i,3}) \sim Multinom(1, p_i, (1-p_i)p_i, (1-p_i)^2)
$$
All mussels (or clusters) with $Y_{i,1} = 1$ or $Y_{i,2} = 1$ are kept as our double removal distance sample and their distance along and distance from the transect are recorded. **Note that this sampling method assumes perfect detection on the transect.** 


```{r}
sigma <- .25
w <- 1
set.seed(4543)
dist.i <- zeebDistSamp(zpop, x.samp, len, sigma, w, dtype = "double", cluster = FALSE)
length(unique(dist.i$transect)); n
dist.c <- zeebDistSamp(zpop, x.samp, len, sigma, w, dtype = "double", cluster = TRUE)
```

```{r}
dist.i %>% 
ggplot() + 
  geom_point(aes(x=dist,y=y, color = DoubleObserver)) + 
  geom_vline(xintercept = 0, linetype = 2) + 
  scale_color_manual(values = c("red","blue"), limits = c("firstObs","secondObs")) + 
  ggtitle("Double observer - distance sampling individuals") 
```

#### Estimation

The `mrds` package was used to estimate mussel density (number/square meter) in the region of interest. This package uses estimation methods from Laake and Borchers (2004). 

```{r}
# individual sample
dist.i.clean <- cleanSample(dist.i, design = "distance", cluster = FALSE)
distEst( dist.i.clean, len, w, n.tran, wid, type = "model.mrds", cluster = FALSE) 
# cluster sample
dist.c.clean <- cleanSample(dist.c, design = "distance", cluster = TRUE)
distEst( dist.c.clean, len, w, n.tran, wid, type = "model.mrds", cluster = TRUE) 
```


#### 1.3.2 double transect sampling

A sample of mussels is simulated by selecting an individual mussel or a cluster of mussels. Sampling was conducted along a transect with a half-width of $w_{dt} = 0.5$ (dimesions of sampled transect are 20mx1m). 

- `cluster = FALSE`: Individual mussel detection probabilities  are $p$ for all mussels. 
- `cluster = TRUE`: Cluster detection probabilities are equal to 
$$
p_c = \dfrac{e^{\beta_0 + \beta_1 s_c} }{1+ e^{\beta_0 + \beta_1 s_c}} 
$$
where $s_c$ is the number of mussels in cluster $c$. The intercept $\beta_0$ is equal to 
$$
\beta_0 = log(\frac{p}{1-p}) - \beta_1
$$
so that $p_c = p$ when a cluster is of size $s_c  = 1$. 

Similar as the distance removal sampling, a detection (or not) history is generated as
$$
(Y_{i,1}, Y_{i,2}, Y_{i,3}) \sim Multinom(1, p_i, (1-p_i)p_i, (1-p_i)^2)
$$
All mussels (or clusters) with $Y_{i,1} = 1$ or $Y_{i,2} = 1$ are kept as our double removal distance sample and their distance along and distance from the transect are recorded. 

```{r}
p <- .2
beta1 <- .2
beta0 <- log(p/(1-p)) - beta1   # intercept so p.clus = p when size = 1.
curve(plogis(beta0 + beta1*x), from=1, to=30)
w.dt <- .5
set.seed(4543)
dt.i <- zeebDoubleRemSamp(zpop, x.samp, len, p, beta1, w.dt,  cluster = FALSE)
length(unique(dt.i$transect)); n
dt.c <- zeebDoubleRemSamp(zpop, x.samp, len, p, beta1, w.dt,  cluster = TRUE)
```

```{r}
dt.i %>% 
ggplot() + 
  geom_point(aes(x=dist,y=y, color = DoubleObserver)) + 
  geom_vline(xintercept = 0, linetype = 2) + 
  scale_color_manual(values = c("red","blue"), limits = c("firstObs","secondObs")) + 
  ggtitle("Double observer - no distance sampling individuals") 
```

#### Estimation

Two estimation methods were considered (design and model based) along with two separate packages

- Design based: Using the `FSA` package, we can compute the estimated density of the sampled area. For each transect, we estimate the detection probability of individual mussels based on mussels counts for the two observers. These estimates are summed across transects and divided by area sampled. 

- Model based: The `unmarked` package will compute model-based estimates of density in the sampled area. The model we use is a Poisson/Multinomial mixture model where transect abundance $N_i$ is model as
$$
N_j \sim Pois(\lambda)
$$
The mussel (not cluster) removal counts for transect $j$ are modeled as 
$$
(N_{j,1}, N_{i,2}, N_{i,3}) \sim Multinom(N_j, p, (1-p)p, (1-p)^2)
$$
where $N_j = \sum_{t = 1}^3n_{j,t}$ and $p$ represents the probability that an individual mussel is detected. As with the design-based estimates, transect-level estimates are computed then combined to get an estimated density for the sampled region. Note that estimates from this package are prone to convergence issues (with MLE estimation via `optim`) and very large abundance estimates can be produced (or the function fails).

```{r}
# individual
dt.i.clean <- cleanSample(dt.i, design = "removal", cluster = FALSE)
dtEst(dt.i.clean, len, w.dt, n.tran = n, type = "designEst.FSA", cluster = FALSE)
dtEst(dt.i.clean, len, w.dt, n.tran = n, type = "MultPois.unmarked", cluster = FALSE)
# cluster
dt.c.clean <- cleanSample(dt.c, design = "removal", cluster = TRUE)
dtEst(dt.c.clean, len, w.dt, n.tran = n, type = "designEst.FSA", cluster = TRUE)
dtEst(dt.c.clean, len, w.dt, n.tran = n, type = "MultPois.unmarked", cluster = TRUE)
```

#### 1.3.3 Quadrat sampling

This method assumes perfect detection within a quadrat, so the only randomness comes from the initial random selection of transects. Along each transect two square with sides `quad.dim` is placed on either side of the transect at distance `x.dist.btw` apart (measures the gap between quads). The bottom sides of each quadrat pair are placed along the transect at a distance `y.dist.btw` apart (so there is a `y.dist.btw` minus `quad.dim` gap between quads). Since we are not assuming a repeated sampling of each quad, we are assuming perfect detection of mussels within each quad. 

The sampling function `zeebQuadSamp` does allow the user sampling imperfectly with mussel detection parameter `p`. A similar method as the double removal sampling method is used to obtain a cluster level detection probability based on cluster size. 


```{r}
y.dist.btw <- 2   # distance between start of sampled quads
quad.dim <- .5   # square quad side size
x.dist.btw <- 1
p.quad <- 1  # detection rate of mussels
beta1.quad <- 0 # only for cluster
quad.i <- zeebQuadSamp(zpop, x.samp, len, p = p.quad, beta1 = beta1.quad, quad.dim = quad.dim, x.dist.btw = x.dist.btw, y.dist.btw = y.dist.btw, cluster = FALSE)
length(unique(quad.i$transect));n
quad.c <- zeebQuadSamp(zpop, x.samp, len, quad.dim = quad.dim, x.dist.btw = x.dist.btw, y.dist.btw = y.dist.btw, cluster = TRUE)
```

```{r}
quad.i %>% 
ggplot() + 
  geom_point(aes(x=dist,y=y)) + 
  geom_vline(xintercept = 0, linetype = 2) + 
  scale_color_manual(values = c("red","gray")) + 
  ggtitle("quad sampling - individuals") + 
  geom_hline(yintercept = (0:(len/y.dist.btw - 1)) * y.dist.btw, linetype = 3) +   
  geom_hline(yintercept = quad.dim + (0:(len/y.dist.btw - 1)) * y.dist.btw, linetype = 3)
```

#### Estimation

A design-based estimate of density is computed from the quadrat data by simply adding up the observed mussel counts and dividing by the sampled area. 

```{r}
# individual
quad.i.clean <- cleanSample(quad.i, design = "quad", cluster = FALSE)
quadEst(quad.i.clean, quad.dim, len, y.dist.btw, n.tran  = n, cluster = FALSE) 
# cluster    
quad.c.clean <- cleanSample(quad.c, design = "quad", cluster = TRUE)
quadEst(quad.c.clean, quad.dim, len, y.dist.btw, n.tran  = n, cluster = TRUE)
```


## 2. Simulation run 

### 2.1 get population

```{r}
# lake florida density ~ 0.05  use lam2 = 0, lam1 = 4000
# lake burgan density ~ .5  use lam2 = .4, lam1 = 4000*6
# little birch density ~ 25 use lam2 = 5, lam1 = 4000*80
len <- 20   # transect length
wid <- 4000  # width of lake (circumference)
lam1 <- 4000*3  # mean number of clusters
lam2 <- 30     # mean cluster size = lam2 + 1
lam1*(lam2+1)  # expected number of mussels
lam1*(lam2+1)/(len*wid)  # expected density
r <- .02*1  # Poisson process radius: larger r means less clustering and more randomness (mean dist)
r.fixed <- 2*r # fixed max distance for Matern process
type.pop <- "nbp"  # "none", "pp", "nbp"
set.seed(863)
zpop <- zeebPop(len, wid, lam1, lam2, disp = 1, r.pois = r, type = type.pop)
(density.zpop <- nrow(zpop)/(len*wid))
```

### 2.2 Sample design
```{r}
n <- n.tran <- 20   # number of transects

# distance double removal design
sigma <- .25
w <- 1
# double transect removal design (no distance)
p <- .2
beta1 <- .2
w.dt <- .5
# quad design
y.dist.btw <- 2   # distance between start of sampled quads
quad.dim <- .5   # square quad side size
x.dist.btw <- 1
```

### 2.3 Simulation

```{r}
N.sim <- 500
```
```{r sim, cache = TRUE}

sim.df <- data_frame()

for (i in 1:N.sim)
{
  x.samp1 <- runif(1,0,wid/n)  #systematic
  x.samp <- c(x.samp1, x.samp1 + (1:(n-1))*wid/n)
  
  # double distance - individual
  dist.i <- zeebDistSamp(zpop, x.samp, len, sigma, w, dtype = "double", cluster = FALSE) 
  if (nrow(dist.i) > 0) {
  sim.df <- sim.df %>% bind_rows(
    distEst( cleanSample(dist.i, design = "distance", cluster = FALSE), len, w, n.tran, wid, type = "model.mrds", cluster = FALSE) %>% 
      mutate(sigma)) }
  
  # double distance - cluster
  dist.c <- zeebDistSamp(zpop, x.samp, len, sigma, w, dtype = "double", cluster = TRUE) 
  if (nrow(dist.c) > 0) {
  sim.df <- sim.df %>% bind_rows(
    distEst( cleanSample(dist.c, design = "distance", cluster = TRUE), len, w, n.tran, wid, type = "model.mrds", cluster = TRUE) %>% 
      mutate(sigma)) }
  
  # quad - individual
  quad.i <- zeebQuadSamp(zpop, x.samp, len, quad.dim = quad.dim, x.dist.btw = x.dist.btw, y.dist.btw = y.dist.btw, cluster = FALSE)
  if (nrow(quad.i) > 0) {
  sim.df <- sim.df %>% bind_rows(
    quadEst(cleanSample(quad.i, design = "quad", cluster = FALSE),quad.dim, len, y.dist.btw, n.tran  = n, cluster = FALSE) %>%
    mutate(p.detect.ind = 1)) }
  
  # quad - cluster
  quad.c <- zeebQuadSamp(zpop, x.samp, len, quad.dim = quad.dim, x.dist.btw = x.dist.btw, y.dist.btw = y.dist.btw, cluster = TRUE)
  if (nrow(quad.c) > 0) {
  sim.df <- sim.df %>% bind_rows(
    quadEst(cleanSample(quad.c, design = "quad", cluster = TRUE), quad.dim, len, y.dist.btw, n.tran  = n, cluster = TRUE) %>%
    mutate(p.detect.ind = 1))  }
  
  # double removal transect - individual
  dt.i <- zeebDoubleRemSamp(zpop, x.samp, len, p, beta1, w.dt,  cluster = FALSE)
  if (nrow(dt.i) > 0) {
  sim.df <- sim.df %>% bind_rows(
    dtEst(cleanSample(dt.i, design = "removal", cluster = FALSE), len, w.dt, n.tran = n, type = "designEst.FSA", cluster = FALSE) %>%
      mutate(p.detect.ind = p))
  sim.df <- sim.df %>% bind_rows(
    dtEst(cleanSample(dt.i, design = "removal", cluster = FALSE), len, w.dt, n.tran = n, type = "MultPois.unmarked", cluster = FALSE) %>%
      mutate(p.detect.ind = p)) }
  
    # double removal transect - cluster
  dt.c <- zeebDoubleRemSamp(zpop, x.samp, len, p, beta1, w.dt,  cluster = TRUE)
  if (nrow(dt.c) > 0){
  sim.df <- sim.df %>% bind_rows(
    dtEst(cleanSample(dt.c, design = "removal", cluster = TRUE), len, w.dt, n.tran = n, type = "designEst.FSA", cluster = TRUE) %>%
      mutate(p.detect.ind = p, beta1.clus.size = beta1))
  sim.df <- sim.df %>% bind_rows(
    dtEst(cleanSample(dt.c, design = "removal", cluster = TRUE), len, w.dt, n.tran = n, type = "MultPois.unmarked", cluster = TRUE) %>%
      mutate(p.detect.ind = p, beta1.clus.size = beta1)) }

  if (i %% 100 == 0) print(i)
}

```

```{r, fig.height= 7}
ggplot(sim.df, aes(y = Dest, x = cluster)) + 
  geom_boxplot() + 
  facet_wrap(~design + type) + 
  geom_hline(yintercept = density.zpop, color="red") + 
  scale_y_log10()
sim.df %>% group_by(design, type, cluster) %>%
  summarize(n = n(),
            mean = mean(Dest, na.rm = TRUE), 
            sd = sd(Dest, na.rm = TRUE), 
            q025 = quantile(Dest, .025, na.rm = TRUE), 
            q975 = quantile(Dest, .975, na.rm = TRUE), 
            q25 = quantile(Dest, .25, na.rm = TRUE), 
            q75 = quantile(Dest, .75, na.rm = TRUE), 
            med = median(Dest, na.rm = TRUE))
density.zpop
```

some observations

- higher density: (D=4.5) all estimators (rem, quad) look about unbiased
    - with pp clustering: FSA, unmarked SE's about half of the quad design SE (.6, 1.2)
    - without clustering ("none"): all SE's look similar (about .2)
    


## 3. Multiple Simulations

The simulation above was repeated for a variety of populations, varying in density (low to high) and clustering (low to high). Preliminary results were obtained for 52 combinations of populations with 100. As mentioned above, results from `unmarked` are suspect since extreme results are obtained when the the `optim` algorithm doesn't converge (or yields suspiciously low detection probabilities). 

### 3.1

Design information used to generate samples under each design:
  
- Double Distance: $\sigma = 0.25$
- Double Transect: $p = 0.2$ and $\beta_1 = 0.2$
- Quadrat: $p = 1$ (perfect detection)

```{r}
multiSim.out.df <- readRDS("output/multiSim.out.df.nsim100.rds")
multiSim.out.df <- multiSim.out.df %>% mutate(DesignInfo = paste(design, type))  #, sigma, p.detect.ind, beta1.clus.size
```

```{r}
pd <- position_dodge(.1)

multiSim.out.df %>% 
  filter(!cluster) %>%
  ggplot(aes(x=exp.density, y = med - density.zpop, color = as.factor(r))) +
    geom_errorbar(aes(ymin = q25 - density.zpop, ymax = q75 - density.zpop, linetype = as.factor(lam2 + 1)), position = pd) + 
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Individual mussels sampled: Median and 2.5/97.5 quantile range")+ 
  xlab("expected population density")
```

```{r}
multiSim.out.df %>% 
  filter(cluster) %>%
  ggplot(aes(x=exp.density, y = med - density.zpop, color = as.factor(r))) +
    geom_errorbar(aes(ymin = q25 - density.zpop, ymax = q75 - density.zpop, linetype = as.factor(lam2 + 1)), position = pd) + 
    geom_point(aes(shape = as.factor(lam2 + 1)),position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Clusters sampled: Median and 2.5/97.5 quantile range")+ 
  xlab("expected population density")

```

Relative Bias
```{r}
multiSim.out.df %>% mutate(PercentBias = 100*(med - density.zpop)/density.zpop) %>%
  filter(!cluster, PercentBias < 500) %>%
  ggplot(aes(x=exp.density, y = PercentBias, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Individual mussels sampled: Percent Bias (bias/truth) using median")+ 
  xlab("expected population density")
```

```{r}
multiSim.out.df %>% mutate(PercentBias = 100*(med - density.zpop)/density.zpop) %>%
  filter(cluster, PercentBias < 500) %>%
  ggplot(aes(x=exp.density, y = PercentBias, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Clusters sampled: Percent Bias (bias/truth) using median")+ 
  xlab("expected population density")
```


Relative IQR 
```{r}
multiSim.out.df %>% mutate(PercentIQR = 100*(q75 - q25)/density.zpop) %>%
  filter(!cluster, PercentIQR < 500) %>%
  ggplot(aes(x=exp.density, y = PercentIQR, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Individual mussels sampled: Percent IQR (IQR/truth)")+ 
  xlab("expected population density")
```
```{r}
multiSim.out.df %>% mutate(PercentIQR = 100*(q75 - q25)/density.zpop) %>%
  filter(cluster, PercentIQR < 500) %>%
  ggplot(aes(x=exp.density, y = PercentIQR, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Clusters sampled: Percent IQR (IQR/truth)")+ 
  xlab("expected population density")
```

### 3.2 Scenario II

Design information used to generate samples under each design:
  
- Double Distance: $\sigma = 0.5$
- Double Transect: $p = 0.2$ and $\beta_1 = 0$
- Quadrat: $p = 0.8$ and $\beta_1 = 0$ (imperfect detection)


```{r}
multiSim.out.df <- readRDS("output/multiSim.out.df.nsim100.beta0.rds")
multiSim.out.df <- multiSim.out.df %>% mutate(DesignInfo = paste(design, type))  #, sigma, p.detect.ind, beta1.clus.size
```


```{r}
pd <- position_dodge(.1)

multiSim.out.df %>% 
  filter(!cluster) %>%
  ggplot(aes(x=exp.density, y = med - density.zpop, color = as.factor(r))) +
    geom_errorbar(aes(ymin = q25 - density.zpop, ymax = q75 - density.zpop, linetype = as.factor(lam2 + 1)), position = pd) + 
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Individual mussels sampled: Median and 2.5/97.5 quantile range")+ 
  xlab("expected population density")
```

```{r}
multiSim.out.df %>% 
  filter(cluster) %>%
  ggplot(aes(x=exp.density, y = med - density.zpop, color = as.factor(r))) +
    geom_errorbar(aes(ymin = q25 - density.zpop, ymax = q75 - density.zpop, linetype = as.factor(lam2 + 1)), position = pd) + 
    geom_point(aes(shape = as.factor(lam2 + 1)),position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Clusters sampled: Median and 2.5/97.5 quantile range")+ 
  xlab("expected population density")

```

Relative Bias
```{r}
multiSim.out.df %>% mutate(PercentBias = 100*(med - density.zpop)/density.zpop) %>%
  filter(!cluster, PercentBias < 500) %>%
  ggplot(aes(x=exp.density, y = PercentBias, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Individual mussels sampled: Percent Bias (bias/truth) using median")+ 
  xlab("expected population density")
```

```{r}
multiSim.out.df %>% mutate(PercentBias = 100*(med - density.zpop)/density.zpop) %>%
  filter(cluster, PercentBias < 500) %>%
  ggplot(aes(x=exp.density, y = PercentBias, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Clusters sampled: Percent Bias (bias/truth) using median")+ 
  xlab("expected population density")
```


Relative IQR 
```{r}
multiSim.out.df %>% mutate(PercentIQR = 100*(q75 - q25)/density.zpop) %>%
  filter(!cluster, PercentIQR < 500) %>%
  ggplot(aes(x=exp.density, y = PercentIQR, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Individual mussels sampled: Percent IQR (IQR/truth)")+ 
  xlab("expected population density")
```
```{r}
multiSim.out.df %>% mutate(PercentIQR = 100*(q75 - q25)/density.zpop) %>%
  filter(cluster, PercentIQR < 500) %>%
  ggplot(aes(x=exp.density, y = PercentIQR, color = as.factor(r))) +
    geom_point(aes(shape = as.factor(lam2 + 1)), position = pd) + 
   geom_line(position = pd) + 
    facet_wrap(~ (DesignInfo) , scales = "free") + 
    scale_x_log10() + 
    geom_hline(aes(yintercept = 0)) + 
  ggtitle("Clusters sampled: Percent IQR (IQR/truth)") + 
  xlab("expected population density")
```
